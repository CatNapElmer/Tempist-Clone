<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Tempist-Clone</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { margin:0; background:#111; color:#eee; font-family:system-ui; }
    h1, .ver, .hint { text-align:center; }
    canvas { display:block; margin:12px auto 24px; border:1px solid #444; border-radius:8px; }
    .ver { font-size:12px; opacity:.6; margin-top:-6px }
    .hint { opacity:.65; font-size:14px; margin-top:-6px; text-decoration:none; }
    body:focus { outline:0; }
  </style>
</head>
<body tabindex="0">
  <h1>Tempist-Clone</h1>
  <div class="ver">version: <strong>clean v4 (no buttons)</strong></div>
  <p class="hint">Click the page once to focus, then use ◀︎/▶︎ or A/D to move the claw.</p>
  <canvas id="game" width="640" height="480"></canvas>

  <script>
    const c = document.getElementById('game');
    const ctx = c.getContext('2d');

    // Web parameters
    const LANES = 12, RINGS = 6, OUTER_R = 200, SHRINK = 0.72;
    const CX = c.width/2, CY = c.height/2 + 30, TAU = Math.PI*2;

    // Claw parameters
    const CLAW_WIDTH = 0.35;   // fraction of a lane
    const CLAW_INSET = 28;     // px inward from rim
    const EASE = 0.22;         // smoothing toward target

    // Precompute ring radii
    const radii = []; { let r = OUTER_R; for (let i=0;i<RINGS;i++){ radii.push(r); r *= SHRINK; } }
    const laneAngle = k => (k/LANES)*TAU - Math.PI/2;
    const posAt = (a,r) => [CX + Math.cos(a)*r, CY + Math.sin(a)*r];

    // Player state
    let curT = 0, targetT = 0;

    // Ensure page gets focus so key events fire
    const ensureFocus = () => { if (document.activeElement !== document.body) document.body.focus(); };
    addEventListener('pointerdown', ensureFocus, {passive:true});
    addEventListener('load', ensureFocus);

    // Keyboard controls
    document.addEventListener('keydown', (e)=>{
      const k = e.key;
      if (k === 'ArrowLeft' || k === 'a' || k === 'A'){ e.preventDefault(); targetT -= 1; }
      if (k === 'ArrowRight' || k === 'd' || k === 'D'){ e.preventDefault(); targetT += 1; }
    });

    function drawWeb(){
      // solid clear (nothing leftover underneath)
      ctx.fillStyle = '#111';
      ctx.fillRect(0,0,c.width,c.height);

      ctx.lineWidth = 2;
      ctx.strokeStyle = '#0ff';

      // Rings
      ctx.globalAlpha = 0.85;
      for (const r of radii){
        ctx.beginPath();
        for (let k=0;k<LANES;k++){
          const a = laneAngle(k);
          const [x,y] = posAt(a, r);
          k===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
        }
        ctx.closePath();
        ctx.stroke();
      }

      // Radials
      ctx.globalAlpha = 1;
      const inner = radii[radii.length-1];
      for (let k=0;k<LANES;k++){
        const a = laneAngle(k);
        const [x0,y0] = posAt(a, OUTER_R);
        const [x1,y1] = posAt(a, inner);
        ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
      }
    }

    function drawClaw(t){
      const frac = ((t % LANES) + LANES) % LANES;
      const aC = laneAngle(frac);
      const span = (TAU / LANES) * CLAW_WIDTH;
      const aL = aC - span, aR = aC + span;

      const [bx1,by1] = posAt(aL, OUTER_R + 3);
      const [bx2,by2] = posAt(aR, OUTER_R + 3);
      const [tx, ty ] = posAt(aC, OUTER_R - CLAW_INSET);

      ctx.save();
      ctx.shadowColor = '#0ff'; ctx.shadowBlur = 8;
      ctx.beginPath(); ctx.moveTo(bx1,by1); ctx.lineTo(bx2,by2); ctx.lineTo(tx,ty); ctx.closePath();
      ctx.fillStyle = '#0ff'; ctx.fill();
      ctx.shadowBlur = 0; ctx.lineWidth = 2; ctx.strokeStyle = '#033'; ctx.stroke();
      ctx.restore();
    }

    function loop(){
      curT += (targetT - curT) * EASE;
      drawWeb();
      drawClaw(curT);
      requestAnimationFrame(loop);
    }
    loop();
  </script>
</body>
</html>
